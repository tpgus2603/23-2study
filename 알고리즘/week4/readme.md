
이번주차는 dp와 그래프 문제들을 위주로 백준 문제를 풀었다.  그래프 문제들은 아직 다익스트라나 크루스칼 같은 알고리즘 적용이 아닌 bfs dfs위주 문제여서 풀만했다.

11052 
-

https://www.acmicpc.net/problem/11052

포인트: 그리디로 접근하였지만 이 문제는 그리디하게 풀이하지 못하고 결국 dp로 모든 경우를 풀이해야한다.  
그리디하게 가장 가격/개수가 높은것을 택하려 하였지만 그렇게 해도 절묘하게 가격/개수가 적은것을 택하는 경우가 답이 되는 경우가 나온다. 따라서 그리디로 문제를 풀 경우에는
과연 모든 경우에서 그리디한 접근이 최적해를 나오게 하는지 고려를 해야한다.

2293
-
https://www.acmicpc.net/problem/2293

새로운 방식의 dp-> 테이블을 누적해서 채우는것과 달리 갱신하는 방법 
메모리 제한이 4mb로 문제의 스케일 만큼 2차원으로 dp테이블을 구성하는 경우 메모리 초과가 된다.
따라서 1차원으로 해당 문제를 풀이하는것이 포인트인데 2차원 dp문제를 1차원으로 축소하여 풀이가 가능한 경우가 있다.
이 경우 1차원으로 설정한 dp테이블을 사용한 동전 종류를 늘려가면서 전체를 갱신하는데 갱신하기 이전의 dp테이블 값을 새로 갱신할때 활용해야한다.



9251
-
https://www.acmicpc.net/problem/9251

2차원으로 테이블을 구성하는 문제중 상당히 점화식을 찾기가 어려운 문제다 긴 부분 수열을 구하는 문제와 유사하지만 이 경우는 두가지 문자열을 비교하기에 2차원으로 테이블을 구성하여 행은 1문자열 열은 2 문자열로 간주하여 1행씩 
테이블을 채워나간다.  이 문제의 경우 갱신되는 점화식이 특이하게 이전 행이나 이전열만을 보는것이 아니라 동시에 dp[i-1][j-1]+1로 대각선 방향으로 이전 테이블을 참고한다.
항상 가로방향 혹은 세로방향에서 테이블을 갱신하였기에 이런 방식의 테이블 갱신을 알아둘 필요가 있다.

2294 
-https://www.acmicpc.net/problem/2294

불필요한 배열 및 연산을 줄이는 방법 

이 문제의 경우 첫 풀이를 2차원 테이블과 별도의 판정 테이블까지 만들어서 메모리 공간을 크게잡고 복잡한 연산으로 통과하였다.

하지만 이 문제는 1차원으로도 풀이가 가능하며 훨씬 연산을 줄이는게 가능하다 

dp테이블을 큰 수로 채워두는 방식이다. 다익스트라에서도 비슷한 방식을 사용하는데 만약 dp테이블을 큰수로 채워놓지 않는다면 이전 풀이처럼 판정테이블이 필요하지만 이 문제의 경우 최소값을 택하는 문제여서 미리 큰수를 채워놓는 경우
판정 테이블을 만들지 않고도 풀이가 가능하다.

```
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;
int dp[101][10001];
bool is_make[101][10001];

int main()
{
  int testn;

    int n,m;
    cin>>n>>m;
    int coin[n+1];
    for(int i=1;i<=n;i++)
      cin>>coin[i];
    coin[0]=-1;
    sort(coin,coin+n+1);
    for(int i=0;i<=n;i++)
      is_make[i][0]=1;
    for(int i=1;i<=n;i++)
    {
      for(int j=1;j<=m;j++)
      {
        if(j>=coin[i])
        {
          if(is_make[i][j-coin[i]]&&is_make[i-1][j])
            {
              dp[i][j]=min(dp[i][j-coin[i]]+1,+dp[i-1][j]);
              is_make[i][j]=1;
            }
          else if(is_make[i][j-coin[i]])
            {
              dp[i][j]=dp[i][j-coin[i]]+1;
              is_make[i][j]=1;
            }
            else
            {
              if(is_make[i-1][j])
              {
                dp[i][j]=dp[i-1][j];
                is_make[i][j]=1;
              }
            }
        }
        else
          {
            dp[i][j]=dp[i-1][j];
            if(dp[i][j])
              is_make[i][j]=1;
          }
      }
    }

    if(dp[n][m]==0)
      cout<<-1;
    else
      cout<<dp[n][m]<<'\n';
}


//풀이 2
// using namespace std;
// int n, k;
// int a[10005], d[10005];
// int main(void) {
//   ios::sync_with_stdio(0);
//   cin.tie(0);
//   cin >> n >> k;
//   for (int i = 0; i < n; i++)
//     cin >> a[i];
//   fill(d, d + 10005, 100005);
//   d[0] = 0; // 0원: 0개
//   for (int i = 0; i < n; i++) {
//     for (int j = a[i]; j <= k; j++)
//       // 동전 하나 추가한 값과 기존 값 중 작은값
//       d[j] = min(d[j], d[j - a[i]] + 1);
//   }

//   cout << (d[k] == 100005 ? -1 : d[k]) << '\n';
// }
```
1655 가운데를 말해요 

메모리공간이 여유있을때 접근법...... 우선순위 큐를 사용하는데 예상처럼 
