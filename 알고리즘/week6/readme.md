1865 웜홀 : 

웜홀은 음수 간선이 있는것과 같은 문제이다. 
다익스트라는 음수간선을 처리하지 못하고 플로이드 워셜은 음수간선 자체는 처리가 가능하지만 음수 사이클은 처리하지 못한다. 
다익스트라, 플로이드로는 음수 사이클을 처리하지 못한다.. -> 벨만포드 알고리즘 활용 (시간복잡도는   더 큼)

특히 이 문제는 시작 정점이 정해져있지 않다. 하지만 모든 정점에 대해 벨만포드를 실행하면 시간 초과가 된다.

따라서 이 문제는 기존 벨만포드가 이미 방문한 정점과 연결된 간선에 대해서 거리 테이블을 갱신하지만 특정점과 연결되지 않는 음수 사이클을 찾기 위해

예외적으로 if(d[from]==MAX) continue 를 삭제한다. 이러면 방문하지 않는 정점이 포함된 간선에서도 음수 사이클을 찾아낼 수 있다. 

11657 타임머신...

해당 문제는 출력 초과오류로 인해 한번 틀렸는데 그 이유를 찾기가 어려웠다.  처음에 간선 최대개수가 6000개고 한 간선의 범위가 -10000에서 10000만이기에
int형으로도 오버플로우가 안날거라고 생각했지만 사실 벨만포드 알고리즘은 n번 반복하면서 거리 테이블을 갱신한다. 
따라서 초기에 음수사이클이 발견되고 해당 음수 사이클의 크기가 -6천만이고 이를 500번 반복하게 되면 -테이블의 거리 크기가 30억으로 되면서  int형 범위를 넘어가게된다.

2096 내려가기

- 이 문제는 4mb의 메모리가 주어진 문제인데 메모리 계산이 내 생각과는 달랐다
c++컴파일러는 iostream 헤더파일 사용시 2mb정도를 사용하며 미 사용시 1mb정도를 사용한다
따라서 예상치보다 2mb정도 더 큰 메모리를 소모하였다 

dp에서 테이블을 재활용하면서 메모리를 아끼는 방법을 슬라이딩 윈도우 테크닉이라고 부른다(일반적인 간격을 유지하면서 옆으로 이동하는 슬라이딩 윈도우랑은 다름)

일반적인 슬라이딩 윈도우:
function solution(n, k, arr) {
  let result = 0; // 길이 k의 부분 수열의 요소 전체 합의 최댓값
  let sum = 0; // 특정 부분 수열의 전체 합

  for(let i = 0; i < k; i++) {
    sum += arr[i];
  }

  result = sum;

  for(let i = k; i < arr.length; i++) {
    sum += (arr[i] - arr[i - k]);
    result = Math.max(result, sum);
  } 

2206 벽부수고 이동하기

flag를 넣어서 벽을 부순경우 안부순 경우 분리한다.
또한 벽을 아예 안부순 거리와 벽을 부순적 있는거리를 분리한다. 

16933 벽부수고 이동하기..

낮과 밤을 구분할 새로운 4차원 배열을 만들지.. 아니면 기존 3차원 배열을 활용하여 계산할지... 낮인 거리는 낮에 해당하는 거리를 밤에해당하는거리는 밤에해당하는 거리로 구분해서
계산해야 다른 큐의 요소와 겹치지 않는다..

16236 아기상어

bfs를 써야한다는것은 감이온다 하지만 먹을 수 있는 물고기를 어떤식으로 찾을것이며 매 이동마다 먹을 수 있는 물고기들을 계산해야하나? 
이 부분에서 처음에는 bfs를 하면서 먹이를 찾아가는 방법으로 생각했지만 그러면 당장 사방에없는 먹이를 찾으러가는 부분이 막힌다.
따라서 시간복잡도가 여유있는 만큼 가장 가까운 물고기를 bfs를 통해 탐색하여 타겟을 잡은뒤  다시 bfs를 사용하여 그 먹이를 잡아먹으러 가는 두번의 bfs를 사용하여 구현하였다





