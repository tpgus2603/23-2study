
11444 피보나치수...

점화식을 나열하여 f2k= fk(fk+1+fk-1) 을 구했고
                         f2k-1=fk^2+ fk-1^2을 구했다. 

하지만 분할 정복을 이용하려할때 이를 어떻게 log n스케일로 해야하는지 막혔는데 이때 중복 호출을 
줄이고 이전에 사용한 결과를 이용하는 메모제이션이라는 알고리즘을 사용한다.

메모제이션은 맵을 활용하여 재귀속에서 찾고자 하는 결과가 있으면 이를 반환한다.

또한 모듈러 연산에서  오버플로우를 막기위해 특정 수의 모듈러는 모듈라 인수들의 곱에 마지막 모듈러를 한것과 같다.

탑다운 dp를 메모제이션이라고 생각할 수 있는데 재귀와 map을 통해 큰 문제를 작은문제로 쪼개가면서 중복된 결과를 맵에서 찾아낸다.

멥vs 해쉬맵

정렬된 순서 유지가 필요할 때
키의 순서대로 데이터를 순회해야 하는 경우 map이 유리합니다. 예를 들어, 범위 기반의 쿼리나 순서대로 데이터를 출력해야 하는 상황에서는 map의 정렬된 특성이 매우 유용합니다.
이전/다음 요소에 대한 접근이 필요한 경우, map에서는 키의 순서가 보장되므로 이러한 연산이 자연스럽고 효율적으로 수행될 수 있습니다.
범위 쿼리
특정 범위에 속하는 키들을 찾아야 하는 경우에는 map이 훨씬 유리합니다. map을 사용하면 lower_bound, upper_bound 같은 함수를 이용하여 특정 범위의 키를 효율적으로 찾을 수 있으며, 이는 내부적으로 정렬된 상태를 유지하기 때문에 가능합니다.
메모리 사용과 성능의 예측 가능성
메모리 사용 최적화: 특정 구현에서 map이 unordered_map보다 메모리 사용 측면에서 더 효율적일 수 있습니다. unordered_map은 해시 충돌을 관리하기 위해 추가적인 메모리를 사용할 수 있으며, 해시 테이블의 로드 팩터에 따라 메모리 사용량이 변동될 수 있습니다.
성능의 예측 가능성: map은 최악의 경우에도 O(log n)의 시간 복잡도를 제공합니다. 반면, unordered_map의 성능은 해시 함수의 품질과 데이터 분포에 따라 크게 달라질 수 있으며, 최악의 경우 O(n)까지 느려질 수 있습니다. 일관된 성능이 중요한 애플리케이션에서는 map이 더 예측 가능할 수 있습니다.




1918 후위 표기식

이 문제는 후위 표기식을 구현하는 문제이다 스택에 연산자를 쌓아가며 연산자가 두개 이상 쌓일때 기존 연산자가 우선순위가 높다면 스택에서 꺼내고 낮다면 덮어쓴다. 마지막에 모든 숫자들이 다 들어오면 연산자들을 모두 스택에서 꺼내쓴다. 연산자의 순위를 반환하는 함수를 switch를 통해 구현하는것이 상당히 좋다 동등한 연산자는 같은 점수를 부여하자 소괄호는 가장 마지막에 사라져야하기 때문에 우선순위늘
 제일 낮게 부여하고 만약 ( )이 완성되면 (를 만날때 까지 모든 연산자들을 스택에서 꺼낸다.

5639 이진검색트리

첫 풀이: 전위 순서를 기반으로 하나씩 다시 넣어가면서 bst완성 후 postorder로 다시 돌림  but 최적의 솔루션이 아니다...
재귀적인 방법을 이용하여 순



10830 행렬 제곱...

이 문제는 행렬 계산 방식에 대한 첫 문제였고 분할정복을 적용하며 또한번 문제의 단위때문에 엄청나게 해맨 문제였다...  또한 행렬 계산을하며 배열을 갱신하는 중에 결과값을 계산에 사용한 배열에 저장하면 잘못된 갱신이 될 수 있다는걸 깨달았고. 마지막으로 모듈러 연산을 할때 문제가 1000으로 나눈 나머지를 구하는대 1000이 행렬에 들어간경우 사실 정답은 0을 출력해야하지만
기존 로직으로는 1000을 출력했다.
따라서 범위에 대해 다시한번 검토를 잘 해야겠다는걸 느꼈다. 


17144 미세먼지 안녕

전형적인 구현문제이다. 근데 문제 풀이를 진행하면서 뻘짓을 되게 많이했는데 일단 공기순환 즉 미세먼지를 한칸씩 옆으로 순환시키는 것을 처음에 스택을 이용하려 했으나
그럴 필요없이 스택을 이용하는 경우는 한칸씩 밖에 이동을 못하여 전체를 한칸씩 미는 것이 불가능하다. 따라서 근본적인 방법인 각 줄마다 반복문을 구성하면서 끝에서 부터 한칸씩 밀면 된다.  순환의 시작점을 잡고 그 점을 중심으로 한칸씩 옮긴다. 

또한 좌표 인덱스를 순간헷갈렸는데 x축의 증가방향이  좌표상에서 아래방향임을 명심하자 마지막으로 이전에도 몇번 헤맨적이 있는 포인트인데 반복문 속에서 변화하는 배열을 구현하는 경우
배열의 변화상태가 다음 배열의 변화에 영향을 주는지 안주는지도 고민하자
